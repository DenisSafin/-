строка импорта

защита  is_palindrome ( данные ):
    # Удаляем пробелы и приводим к сохранению реестра
    данные  =  '' . join ( c . Lower () для  c  в  данных  , если  c . isalnum ())
    возвращаемые  данные  ==  данные [:: - 1 ]

защита  test_is_palindrome ():
    test_cases  = [
        ( «радар» , Правда ),
        ( «уровень» , Истина ),
        ( «привет» , ложь ),
        ( «гоночная машина» , Правда ),
        ( «полдень» , Правда ),
        ( «Питон» , Ложь ),
        ( "" , True ),   # Пустая строка
        ( "A" , True ),   # Односимвольная строка
        ( "мадам" , Правда ),   # Палиндром с нечетным использованием символов
        ( "abba" , True ),   # Палиндром с четным набором символов
        ( "12321" , True ),   # Палиндром, содержат только цифры
        ( "Человек - план Панамского канала" , Правда ),   # Палиндром с пробелами и заглавными буквами
        ( «Я видел машину или кошку?» , Правда ),   # Палиндром с пробелами, знаками препинания и заглавными буквами
        ( «не палиндром» , False ),   # Непалиндром с пробелами и заглавными буквами
        ( "1234567890" , False ),   # Строка без палиндрома
        ( "Человек, план, канал, Панама" , Правда ),   # Палиндром с пробелами, запятыми и заглавными буквами
        ( «Мистер Сова съел моего металлического червяка» , Правда ),   # Палиндром с пробелами, точками и заглавными буквами
    ]

    для  данных , ожидаемых  в  test_cases :
        результат  =  is_palindrome ( данные )
        если  результат  ==  ожидается :
            распечатать ( «ДА» )
        еще :
            напечатать ( «НЕТ» )
            возвращаться

test_is_palindrome ()
 24 изменения: 24 добавления и 0 удалений24 
10.py
@@ -0,0 +1,24 @@
защита  count_chars ( s ):
    если  не  isinstance ( s , str ):
        поднять  TypeError ( «Ввод должен быть строкой» )

    char_count  = {}
    для  char  в  s :
        если  char  в  char_count :
            char_count [ символ ] +=  1
        еще :
            char_count [ символ ] =  1
    вернуть  количество символов

защита  основного ():
    пытаться :
        input_string  =  input ( "Введите код: " )
        результат  =  count_chars ( input_string )
        print ( "Результат подсчета символов:" )
        для  char , подсчитайте  результат  .​ предметы ():
            print ( f"' { char } ': { count } " )
    кроме  TypeError  как  e :
        print ( f"Ошибка: { e } " )

если  __name__  ==  "__main__" :
    основной ()
 13 изменений: 13 добавлений и 0 удалений13 
11.py
@@ -0,0 +1,13 @@

защита  check_phone_number ( телефон ):
    телефон  =  '' . join ( filter ( str . isdigit , phone ))   # Выбираем все символы-НЕцифры
    если  len ( телефон ) ==  11  и  телефон . начинается с ( '7' ):   # Проверяем длину и начало номера
        вернуть  '+'  +  телефон
    Элиф  Лен ( телефон ) ==  10  и  телефон . начинается с ( '8' ):   # Проверяем длину и начало номера
        возврат  '+7'  +  телефон [ 1 :]
    еще :
        вернуть  «ошибку»

phone_number  =  input ( "Введите номер телефона: " )
форматированный_номер_телефона  =  проверочный_номер_телефона ( номер_телефона )
распечатать ( форматированный_номер_телефона )
 15 изменений: 15 добавлений и 0 удалений15 
111.py
@@ -0,0 +1,15 @@
защита  check_phone_number ( телефон ):
    пытаться :
        телефон  =  '' . join ( filter ( str . isdigit , phone ))   # Выбираем все символы-НЕцифры
        если  len ( телефон ) ==  11  и  телефон . начинается с ( '7' ):   # Проверяем длину и начало номера
            вернуть  '+'  +  телефон
        Элиф  Лен ( телефон ) ==  10  и  телефон . начинается с ( '8' ):   # Проверяем длину и начало номера
            возврат  '+7'  +  телефон [ 1 :]
        еще :
            поднять  ValueError ( «Некорректный формат» )
    кроме ( ValueError , IndexError ):
        вернуть  «ошибку»

phone_number  =  input ( "Введите номер телефона: " )
форматированный_номер_телефона  =  проверочный_номер_телефона ( номер_телефона )
распечатать ( форматированный_номер_телефона )
 6 изменений: 6 добавлений и 0 удалений6 
111.txt
@@ -0,0 +1,6 @@
Привет
мое имя
Арсен
Артурович
ПИ-2ИВТ222Б
УУСТ
 3 изменения: 3 добавления и 0 удалений3 
12.txt
@@ -0,0 +1,3 @@
дом
дерево
Гарри Поттер
 19 изменений: 19 добавлений и 0 удалений19 
2.py
@@ -0,0 +1,19 @@
 строка импорта

защита  is_palindrome ( данные ):
    # Удаляем пробелы и приводим к сохранению реестра
    данные  =  '' . join ( c . Lower () для  c  в  данных  , если  c . isalnum ())
    возвращаемые  данные  ==  данные [:: - 1 ]

защита  основного ():
    # Считываем текст из стандартного ввода
    user_input  =  input ( "Введите символы: " )

    # Проверяем, это ли строка палиндромом
    если  is_palindrome ( user_input ):
        распечатать ( «ДА» )
    еще :
        напечатать ( «НЕТ» )

если  __name__  ==  "__main__" :
    основной ()
 32 изменения: 32 добавления и 0 удалений32 
3.py
@@ -0,0 +1,32 @@
импортировать  повторно

def  is_correct_mobile_phone_number_ru ( номер ):
    # Регулярное выражение для проверки номеров телефона
    шаблон  =  r'^(\+7|8)\s?\(?\d{3}\)?[\s-]?\d{3}[\s-]?\d{2}[\ s-]?\d{2}$'

    # Проверяем номер телефона с помощью регулярного выражения
    return  bool ( re . match ( шаблон , число ))

def  test_is_correct_mobile_phone_number_ru ():
    test_cases  = [
        ( «+7(900)1234567» , Правда ),
        ( «+7 900 123 45 67» , Правда ),
        ( «8(900)1234567» , Правда ),
        ( «8 900 123-45-67» , Правда ),
        ( «89001234567» , Правда ),
        ( «+79111234567» , Правда ),
        ( «+7 911 123-45-67» , Правда ),
        ( "abc" , False ),                  # Некорректный формат номера
        ( "+8(900)1234567" , False ),      # Неправильный код страны
        ( "+7(800)123-4567" , Правда ),      # Неправильное количество цифр в номере
    ]

    для  числа , ожидаемого  в  test_cases :
        result  =  is_correct_mobile_phone_number_ru ( номер )
        если  результат  ==  ожидается :
            распечатать ( «ДА» )
        еще :
            напечатать ( «НЕТ» )
            возвращаться

test_is_correct_mobile_phone_number_ru ()
 15 изменений: 15 добавлений и 0 удалений15 
33.py
@@ -0,0 +1,15 @@
защита  check_phone_number ( телефон ):
    пытаться :
        телефон  =  '' . join ( filter ( str . isdigit , phone ))   # Выбираем все символы-НЕцифры
        если  len ( телефон ) ==  11  и  телефон . начинается с ( '7' ):   # Проверяем длину и начало номера
            возврат  '+'  +  телефон , "Формат верный"
        Элиф  Лен ( телефон ) ==  10  и  телефон . начинается с ( '8' ):   # Проверяем длину и начало номера
            верните  '+7'  +  телефон [ 1 :], "Формат верный"
        еще :
            поднять  ValueError ( «Неверное количество цифр» )
    кроме  ValueError :
        вернуть  «ошибку» , «Неверный формат»

phone_number  =  input ( "Введите номер телефона: " )
форматированный_номер_телефона , сообщение  =  проверочный_номер_телефона ( номер_телефона )
печать ( форматированный_номер_телефона , "-" , сообщение )
 21 изменение: 21 добавление и 0 удалений21 
4.py
@@ -0,0 +1,21 @@
импортировать  повторно

def  is_correct_mobile_phone_ru ( номер ):
    # Регулярное выражение для проверки номеров телефона
    шаблон  =  r'^(\+7|8)\s?\(?\d{3}\)?[\s-]?\d{3}[\s-]?\d{2,3} [\s-]?\d{2}$'

    # Проверяем номер телефона с помощью регулярного выражения
    return  bool ( re . match ( шаблон , число ))

защита  основного ():
    # Чтение строк из стандартного ввода
    phone_number  =  input ( "Введите номер телефона: " )

    # Проверка корректности номера телефона
    если  is_correct_mobile_phone_ru ( номер_телефона ):
        распечатать ( «ДА» )
    еще :
        напечатать ( «НЕТ» )

если  __name__  ==  "__main__" :
    основной ()
 29 изменений: 29 добавлений и 0 удалений29 
5.py
@@ -0,0 +1,29 @@
импортировать  повторно
 строка импорта

def  Strip_punctuation_ru ( данные ):
    # Получаем перевод таблицы, где все знаки пунктуации заменяются пробелами
    переводчик  =  ул . maketrans ( '' , '' , строка . пунктуация )
    # Применяем перевод таблицы в строку
    очищенные_данные  =  данные . переводить ( переводчик )
    # Разделяем символы слов, используя обычное выражение, которое наблюдает по последовательности символов
    очищенные_данные  =  повторно . sub ( r'\s+' , '' , очищенные_данные )
    вернуть  очищенные_данные . полоска ()

def  test_strip_punctuation_ru ():
    test_cases  = [
        ( «Привет, как дела?» , «Привет как дела» ),
        ( «Это... тест?» , «Это» ),
        ( «Привет! Как ты?» , «Привет Как ты» ),
        ( «Он сказал: Привет!» , «Он сказал Привет» ),
        ( «Почему? Что, что!» , «Почему что» ),
    ]

    для  данных , ожидаемых  в  test_cases :
        result  =  strip_punctuation_ru ( данные )
        если  результат  ==  ожидается :
            распечатать ( «ДА» )
        еще :
            напечатать ( «НЕТ» )

test_strip_punctuation_ru ()
 17 изменений: 17 добавлений и 0 удалений17 
6.py
@@ -0,0 +1,17 @@
импортировать  повторно
 строка импорта

def  Strip_punctuation_ru ( данные ):
    # Получаем перевод таблицы, где все знаки пунктуации заменяются пробелами
    переводчик  =  ул . maketrans ( строка . пунктуация , ''  *  len ( строка . пунктуация ))
    # Применяем перевод таблицы в строку
    очищенные_данные  =  данные . переводить ( переводчик )
    # Разделяем символы слов, используя обычное выражение, которое наблюдает по последовательности символов
    очищенные_данные  =  повторно . sub ( r'\s+' , '' , очищенные_данные )
    вернуть  очищенные_данные . полоска ()

если  __name__  ==  "__main__" :
    # Пример использования
    input_text  =  input ( "Введите текст на английском языке: " )
    result  =  strip_punctuation_ru ( input_text )
    print ( "Результат обработки:" , результат )
 26 изменений: 26 добавлений и 0 удалений26 
7.py
@@ -0,0 +1,26 @@
импортировать  модульный тест
из  обратного  импорта  обратного

класс  TestReverse ( unittest . TestCase ):
    защита  test_empty_string ( self ):
        себя . AssertEqual ( обратное ( "" ), "" )

    def  test_single_character_string ( self ):
        себя . AssertEqual ( обратный ( «a» ), «a» )

    def  test_palindrome_string ( self ):
        себя . AssertEqual ( обратный ( «радар» ), «радар» )

    def  test_non_palindrome_string ( self ):
        себя . AssertEqual ( обратный ( «привет» ), «оллех» )

    защита  test_non_string ( self ):
        с  собой . AssertRaises ( TypeError ):
            реверс ( 123 )

    def  test_iterable_non_string ( self ):
        с  собой . AssertRaises ( TypeError ):
            обратный ([ 1 , 2 , 3 ])

если  __name__  ==  "__main__" :
    модульный тест . основной ()
 4 изменения: 4 добавления и 0 удалений4 
8 и 9 стартовый код.txt
@@ -0,0 +1,4 @@
pytest count_chars.py 9.py

pytest обратный.py 8.py

 22 изменения: 22 добавления и 0 удалений22 
8.py
@@ -0,0 +1,22 @@
импортировать  pytest
из  обратного  импорта  обратного

защита  test_empty_string ():
    утверждать  обратное ( "" ) ==  ""

защита  test_single_character_string ():
    утверждать  обратное ( "a" ) ==  "a"

защита  test_palindrome_string ():
    утверждать  обратное ( «радар» ) ==  «радар»

защита  test_non_palindrome_string ():
    утверждать  обратное ( «привет» ) ==  «оллех»

защита  test_non_string_non_iterable ():
    с  pytest . повышает ( TypeError ):
        реверс ( 123 )

защита  test_non_string_iterable ():
    с  pytest . повышает ( TypeError ):
        обратный ([ 1 , 2 , 3 ])
 16 изменений: 16 добавлений и 0 удалений16 
9.py
@@ -0,0 +1,16 @@
импортировать  pytest
из  count_chars  импортировать  count_chars

защита  test_count_chars_with_string_input ():
    утверждать  count_chars ( «привет» ) == { 'h' : 1 , 'e' : 1 , 'l' : 2 , 'o' : 1 }

def  test_count_chars_with_empty_string_input ():
    утверждать  count_chars ( "" ) == {}

def  test_count_chars_with_non_string_input ():
    с  pytest . повышает ( TypeError ):
        количество_символов ( 123 )

def  test_count_chars_with_non_string_iterable_input ():
    с  pytest . повышает ( TypeError ):
        count_chars ([ 1 , 2 , 3 ])
 11 изменений: 11 добавлений и 0 удалений11 
count_chars.py
@@ -0,0 +1,11 @@
защита  count_chars ( s ):
    если  не  isinstance ( s , str ):
        поднять  TypeError ( «Ввод должен быть строкой» )

    char_count  = {}
    для  char  в  s :
        если  char  в  char_count :
            char_count [ символ ] +=  1
        еще :
            char_count [ символ ] =  1
    вернуть  количество символов
 17 изменений: 17 добавлений и 0 удалений17 
engine1.py
@@ -0,0 +1,17 @@
def  arithmetic_operation ( операция ):
    if  операция  ==  chr ( 43 ): #+
        вернуть  лямбда  x , y : x  +  y
     операция  elif ==  chr ( 45 ): #-
        вернуть  лямбда  x , y : x  -  y
     операция  elif ==  chr ( 47 ): #/
        вернуть  лямбда  x , y : x  /  y
     операция  elif ==  chr ( 42 ): #*
        вернуть  лямбда  x , y : x  *  y
print ( "Введите операцию \t " )
оп = ул ( вход ())
print ( " \n Введите первое число \t " )
а = число с плавающей запятой ( вход ())
print ( " \n Введите второе число \t " )
b = число с плавающей запятой ( вход ())
ответ  =  арифметическая_операция ( оп )
print ( " \n Ответ:" , "{:.7f}" . format ( ответ ( a , b )))
 28 изменений: 28 добавлений и 0 удалений28 
engine2.py
@@ -0,0 +1,28 @@
def  simple_map ( трансформация , значения , y ):
    а  = []
    для  меня  в  значениях :
        а . добавить ( преобразование ( i , y ))
    вернуть ​
def  arithmetic_operation ( операция ):
    if  операция  ==  chr ( 43 ): #+
        вернуть  лямбда  x , y : x  +  y
     операция  elif ==  chr ( 45 ): #-
        вернуть  лямбда  x , y : x  -  y
     операция  elif ==  chr ( 47 ): #/
        вернуть  лямбда  x , y : x  /  y
     операция  elif ==  chr ( 42 ): #*
        вернуть  лямбда  x , y : x  *  y

иш  = []
n = целое число ( вход ()))
для  i  в  диапазоне ( 0 , n ):
  print ( i + 1 , "Число:" )
  ii = int ( вход ()))
  иш . добавить ( ii )
print ( "Изначальный список: \n " , ish )
print ( "Введите операцию \t " )
оп = ул ( вход ())
print ( " \n Введите число y \t " )
y = целое число ( вход ()))
о = арифметическая_операция ( оп )
print ( "Результатирующий список: \n " , * simple_map ( o , ish , y ))
 26 изменений: 26 добавлений и 0 удалений26 
engine3.py
@@ -0,0 +1,26 @@
ЕДИНИЦА  =  целое число ( вход ()))
ДВА  =  int ( вход ()))
ROMAN_NUM  = { 'M' : 1000 , 'CM' : 900 , 'D' : 500 , 'CD' : 400 , 'C' : 100 , 'XC' : 90 , 'L' : 50 , 'XL' : 40 , 'X' : 10 , 'IX' : 9 , 'V' : 5 , 'IV' : 4 , 'I' : 1 }

защита  романа ():
    глобальный  ОДИН , ДВА
    ТРИ  =  ОДИН  +  ДВА
    романон  =  ''
    для  буквы значение  в  ROMAN_NUM .​ предметы ():
        в то время как  ОДИН  >=  значение :
            романон  +=  буква
            ОДИН  —=  значение
    романдва  =  ''
    для  буквы значение  в  ROMAN_NUM .​ предметы ():
        в то время как  ДВА  >=  значение :
            романдва  +=  буква
            ДВА  -=  значение
    романтри  =  ''
    для  буквы значение  в  ROMAN_NUM .​ предметы ():
        в то время как  ТРИ  >=  значение :
            романтри  +=  буква
            ТРИ  -=  значение
    печать ( романон , "+ " , романтво , "=" , романтри )
    вернуть  0

печать ( римский ())
 28 изменений: 28 добавлений и 0 удалений28 
engine4.py
@@ -0,0 +1,28 @@
А = целое число ( 0 )
Б = целое число ( 0 )
С = целое число ( 0 )
D = целое число ( 0 )
защита  get_transscriptions ( т ):
  глобальный  A , B , C , D
  ни знак равно т . найти ( '-' , 0 , len ( t ))
  НП знак равно т . найти ( ':' , 0 , длина ( т ))
  if  t [ ni + 1 : np ] == "перевод" :
    А += 1
    B += int ( t [ np + 1 : len ( t )])
  elif  t [ ni + 1 : np ] == "оплата_жкх" :
    С += 1
    D += int ( t [ np + 1 : len ( t )])
  вернуть  0


ре = целое число ( 0 )

пока  ре  ==  0 :
  print ( "Введите транзакцию" )
  стр1 = стр ( вход ()))
  get_transscriptions ( str1 )
  print ( "Чтобы ввести ещё одну транзакцию нажмите: 0" )
  re = int ( вход ()))
print ( A , " перевод " , B , " \n " , C , " оплата жкх " , D )


 19 изменений: 19 добавлений и 0 удалений19 
engine5.py
@@ -0,0 +1,19 @@
def  Same_by ( lam , val ):
  r = список ( карта ( лам , вал ))
  т = длина ( значение )
  к = целое число ( 0 )
  для  i  в  диапазоне ( 0 , t ):
    если  р [ я ] == 0 :
      к += 1
  вернуть  т == к

иш  = []
n = целое число ( вход ()))
для  i  в  диапазоне ( 0 , n ):
  print ( i + 1 , "Число:" )
  ii = int ( вход ()))
  иш . добавить ( ii )
if ( same_by ( лямбда  x : x % 2 , ish )):
  распечатать ( «ТО ЖЕ» )
еще :
  печать ( «разные» )
 51 изменение: 51 добавление и 0 удалений51 
палиндром.txt
@@ -0,0 +1,51 @@
импортировать повторно

защита is_palindrome (данные):
    """
    В результате, это строка палиндрома.
    """
    # Удаление пробелов и знаков препинания из строк
    clean_data = re.sub(r'[^A-Za-z0-9]', '', данные)
    return clean_data.lower() == clean_data[::-1].lower()

защита run_tests():
    """
    Тестирование функции is_palindrome().
    """
    тесты = [
        («радар», Правда),
        («уровень», Истина),
        («привет», Ложь),
        ("", True), # Пустая строка считается палиндромом
        («полдень», Правда),
        («Человек, план, канал, Панама», Правда),
        («12321», Правда),
        («гоночная машина», Правда),
        («яблоко», Ложь),
        («васитакароракатисау», «Правда»),
        («госпожа», Правда)
    ]

    для данных ожидаемый_результат в тестах:
        результат = is_palindrome (данные)
        если результат == ожидаемый_результат:
            print(f"Тест пройден для '{data}'")
        еще:
            print(f"Тест не пройден для '{data}'")

    # Печать результата теста
    if all(result == ожидаемый_результат для данных, ожидаемый_результат в тестах):
        печать("НЕТ")
    еще:
        печать("ДА")
# Ввод строк с клавишами
user_input = input("Введите символ для проверки на палиндром: ")

# Проверка введенной строки на палиндроме
если is_palindrome (user_input):
    print("Это палиндром!")
еще:
    print("Это не палиндром.")

# Запуск тестов
run_tests()
 38 изменений: 38 добавлений и 0 удалений38 
телефон.py
@@ -0,0 +1,38 @@

защита  check_phone_number ( телефон ):
    пытаться :
        телефон  =  '' . join ( filter ( str . isdigit , phone ))   # Выбираем все символы-НЕцифры
        если  len ( телефон ) ==  11  и  телефон . начинается с ( '7' ):   # Проверяем длину и начало номера
            код_оператора  =  телефон [ 1 : 4 ]
            если  код_оператора  в [ '910' , '911' , '912' , '913' , '914' , '915' , '916' , '917' , '918' , '919' ,
                                 '980' , '981' , '982' , '983' , '984' , '985' , '986' , '987' , '988' , '989' ]:
                возврат  '+'  +  телефон , "МТС"
            elif  код_оператора  в [ '920' , '921' , '922' , '923' , '924' , '925' , '926' , '927' , '928' , '929' ,
                                   '930' , '931' , '932' , '933' , '934' , '935' , '936' , '937' , '938' , '939' ]:
                возврат  '+'  +  телефон , "МегаФон"
            elif  код_оператора  в [ '902' , '903' , '904' , '905' , '906' ,
                                   '960' , '961' , '962' , '963' , '964' , '965' , '966' , '967' , '968' , '969' ]:
                возврат  '+'  +  телефон , "Билайн"
            еще :
                верните  '+7'  +  телефон [ 1 :], "не определен оператор сотовой связи"
        Элиф  Лен ( телефон ) ==  10  и  телефон . начинается с ( '8' ):   # Проверяем длину и начало номера
            код_оператора  =  телефон [ 0 : 3 ]
            если  код_оператора  в [ '910' , '911' , '912' , '913' , '914' , '915' , '916' , '917' , '918' , '919' ,
                                 '980' , '981' , '982' , '983' , '984' , '985' , '986' , '987' , '988' , '989' ]:
                возврат  '+7'  +  телефон , "МТС"
            elif  код_оператора  в [ '920' , '921' , '922' , '923' , '924' , '925' , '926' , '927' , '928' , '929' ,
                                   '930' , '931' , '932' , '933' , '934' , '935' , '936' , '937' , '938' , '939' ]:
                возврат  «+7»  +  телефон « МегаФон»
            elif  код_оператора  в [ '902' , '903' , '904' , '905' ,
                                   '960' , '961' , '962' , '963' , '964' , '965' , '966' , '967' , '968' , '969' ]:
                возврат  '+7'  +  телефон , "Билайн"
            еще :
                верните  '+7'  +  телефон , "не определен оператор сотовой связи"
        еще :
            поднять  ValueError ( «Неверное количество цифр» )
    кроме  ValueError :
        верните  '+7'  +  телефон [ 1 :], "Неверный формат"

phone_number  =  input ( "Введите номер телефона: " )
форматированный_номер_телефона , сообщение  =  проверочный_номер_телефона ( номер_телефона )
печать ( форматированный_номер_телефона , "-" , сообщение )
 33 изменения: 33 добавления и 0 удалений33 
телефон2.py
@@ -0,0 +1,33 @@

защита  check_phone_number ( телефон ):
    пытаться :
        телефон  =  '' . join ( filter ( str . isdigit , phone ))   # Выбираем все символы-НЕцифры
        если  телефон . начинается с ( '7' ):
            if  len ( телефон ) ==  11 :   # Проверяем длину и начало номера
                код_оператора  =  телефон [ 1 : 4 ]
                если  код_оператора  в [ '910' , '911' , '912' , '913' , '914' , '915' , '916' , '917' , '918' , '919' ,
                                     '980' , '981' , '982' , '983' , '984' , '985' , '986' , '987' , '988' , '989' ]:
                    верните  '+7'  +  телефон [ 1 :], "МТС"
                elif  код_оператора  в [ '920' , '921' , '922' , '923' , '924' , '925' , '926' , '927' , '928' , '929' ,
                                       '930' , '931' , '932' , '933' , '934' , '935' , '936' , '937' , '938' , '939' ]:
                    верните  '+7'  +  телефон [ 1 :], "МегаФон"
                elif  код_оператора  в [ '902' , '903' , '904' , '905' ,
                                       '960' , '961' , '962' , '963' , '964' , '965' , '966' , '967' , '968' , '969' ]:
                    возврат  '+7'  +  телефон [ 1 :], "Билайн"
                еще :
                    верните  '+7'  +  телефон [ 1 :], "не определен оператор сотовой связи"
            еще :
                поднять  ValueError ( «Неверное количество цифр» )
         телефон Элиф . начинается с (( '8' , '+359' , '+55' , '+1' )):
            if  len ( phone ) ==  10  или  len ( phone ) ==  12 :   # Проверяем длину и начало номера
                обратный  телефон , "не определен оператор сотовой связи"
            еще :
                поднять  ValueError ( «Неверное количество цифр» )
        еще :
            поднять  ValueError ( «Не определен код страны» )
    кроме  ValueError  как  e :
        обратный  телефон , ул ( е )

phone_number  =  input ( "Введите номер телефона: " )
форматированный_номер_телефона , сообщение  =  проверочный_номер_телефона ( номер_телефона )
печать ( форматированный_номер_телефона , "-" , сообщение )
 13 изменений: 13 добавлений и 0 удалений13 
различий.py
@@ -0,0 +1,13 @@
а знак равно [ 1 , 2 , 3 ]
б знак равно [ 3 , 2 , 1 ]
в = а + б
а += б
распечатать ( идентификатор ( а ))
распечатать ( идентификатор ( c ))
распечатать ( а )
распечатать ( с )
г знак равно [ 3 , 2 , 1 ]
распечатать ( id ( отсортировано ( g )))
распечатать ( г )
распечатать ( id ( g . sort ()))
распечатать ( г )
 5 изменений: 5 добавлений и 0 удалений5 
обратный.py
@@ -0,0 +1,5 @@
защита  реверса ( s ):
    если  тип ( s ) !=  str :
        поднять  TypeError ( 'Ожидаемая строка, получено {}' . формат ( тип ( s )))

    вернуть  с [:: - 1 ]
